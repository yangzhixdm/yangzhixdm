---
title: 「读书笔记」-linux内核设计与实现-进程管理
date: 2021-12-21 19:55:26
tags: linux
description: 进程就是正在处于执行的程序（目标码存放在某种存储介质上）和各种资源的总称。
---

### 进程
进程不仅仅包含指定的代码片段，还包括资源，挂起的信号，内核内部数据，处理器状态，地址空间或者多个执行线程等。
linux实现线程的机制非常特殊，它对线程和进行并不进行特别区分。对linux而已，线程只不过是一种特殊的进程而已。

进程提供两种虚拟机制： 虚拟处理器和虚拟内存。
线程之间共享虚拟内存，但是独享虚拟处理器。
进程其实就是正在处于执行的程序（目标码存放在某种存储介质上）和各种资源的总称。

创建进程通过fork方法，调用结束的位置，父进程恢复执行，子进程开始执行。
fork方法返回两次，一次回到父进程，一次回到子进程。

通常，创建新的进程都是为了立即执行新的，不同的程序，而接着调用exec这组函数就可以创建新的内存空间，并把新的程序载入其中。现代linux内核中，fork实际上是调用了clone系统调用执行。

> 进程的宁一个名字也叫task。linux内核通常叫task.

### 进程描述符
内核把进程的列表存放在焦作任务队列（task list)的双向循环链表中。链表的每一项都是类型为 task_struct,称为进程描述符的结构。包含一个进程的所有信息。

task_struct包含了一个进程的所有信息：它打开的文件，进程的地址空间，挂起的信号，进程的状态，还有更多的其他信息等。


### 进程状态
TASK_RUNNING 执行中
TASK_INTERRUPTIBLE 可以被中断（睡眠或者阻塞中）
TASK_UNINTERRUPTIBLE 除了就算是就是接收到信号也不会被i唤醒或则准备投入运行外，和TASK_INTERRUPTIBLE 没有区别
__TASK_TRACED 被其他进程跟踪的进程
__TASK_STOPPED 进程停止运行


### 进程上下文
可执行代码被载入到进程的地址空间中执行。一般程序在用户空间执行，当一个程序执行了系统调用活和触发了某个异常，它就陷入了内核空间。此时，我们称内核‘代表进程执行’并处于进程上下文中。在此上下中，current 宏是有有效的。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应的调整，否则在内核退出的时候，程序恢复在用户空间继续执行。

### 进程家族树
unix中进程存在明显的继承关系。所有的进程都是PID为1 的进程的后代。内核在系统启动的最后阶段启动init进程。
系统中每一个进程必有一个父进程，相应的每个进程也可能有零个或者多个子进程。拥有同一个父进程的所有进程被称为兄弟。进程间的关系存放在进程描述符中。每个task_struct中都存有一个parent的指针，指向父进程task_struct.还有一个children的子进程链表。

### 进程创建
linux系统通过两个系统调用： fork和 exec
fork拷贝当前进程创建一个子进程，子进程和父进程的区别仅在与PID和PPID和某些资源和统计量（例如，挂机的信号，它没有必要继承）
exec 负责读取可执行文件并将其载入到地址空间开始运行。

#### 写时拷贝
linux fork 使用写时拷贝(copy-on-write),推迟拷贝甚至免除拷贝的技术。调用fork此时并不复制整个进程的地址空间，而是让父进程和子进程共享同一个拷贝。
只有在写入的时候，数据才会被复制，从而使各个进程拥有自己的拷贝。也就是说，在此之前，只是以只读的方式共享，这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候才执行。
fork的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。

#### fork
linux 通过 clone() 系统调用实现 fork()。然后 clone 会去调用 do_fork() 
do_fork 完成大部分的工作，然后调用 copy_process 函数，然后让进程开始运行。
copy_process执行过程：
①调用dup_task_struct为新进程创建一个新的内核栈，thread_info结构和task_struct，这些值与当前进程的值相同，进程描述符也相同。
②检查确保创建子进程后，当前用户拥有的进程数没有超出为其分配的资源限制
③进程描述符内的许多成员都被清零或初始化，以与父进程区分开来，统计信息一般不继承，task_struct中的大多数数据依然未修改。
④子进程状态被设置为TASK_UNINTERRUPTIBLE，以保证它不会投入运行。
⑤copy_process调用copy_flags()，更新task_struct的flag成员。
⑥调用alloc_pid()为新进程分配一个有效的PID。
⑦根据传递给clone()的参数标识，拷贝或共享打开的文件，信号处理函数，进程地址空间等。
⑧最后copy_process做收尾工作，返回一个指向子进程的指针。

返回到do_fork()，如果copy_process()成功返回，子进程被唤醒并投入运行，内核有意选择子进程首先执行。（父进程先执行可能会向地址空间写入）

### vfork
除了不拷贝父进程页表项外，vfork()系统调用与fork（）功能相同，子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，直到子进程推出或执行exec().

### 线程在Linux中的实现

从内核角度来看，并没有线程这个概念，Linux把所有线程都当作进程来实现，内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程，它仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的task_struct.
对于多个线程并行，Linux只是为每个线程创建普通的task_struct的时候指定他们共享某些资源。

#### 创建线程
线程创建与普通进程创建类似，只不过在调用clone（）的时候需要会传递一些参数标识来指明需要共享的资源.

#### 内核线程
内核经常需要在后台执行一些操作，这种任务可以通过内核线程来完成---独立运行在内核空间的标准线程。它和普通线程的区别在于，内核线程没有独立的进程空间(指向地址空间的mm指针为NULL)，只在内核运行。跟普通线程一样可以被调度，也可以被抢占。

内核线程只能由其他内核线程创建，Linux是通过从kthread内核进程衍生出所有新的内核线程的。

### 进程终结
一个进程终结时，内核必须释放它占有的资源并把这告知其父进程。
显示调用exit()（C编译器会在main()函数的返回点后面放置调用exit()的代码），或者当进程接收到它既不能处理也不能忽略的信号或异常时，它还可能被动的终结。

不管以何种方式终结，大部分都要靠do_exit()来完成，它做以下工作：

①将task_struct中的标志成员设置为PF_EXITING。
②调用del_timer_sync()删除任一内核定时器，根据返回结果，确保没有定时器在排队，也没有定时器处理程序在运行。
③如果BSD的进程记账功能开启，do_exit()会调用act_update_integrals()来输出记账信息。
④调用exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用它们（即该地址空间没有被共享），就彻底释放他们。
⑤调用sem__exit()，如果进程排队等候IPC信号，它则离开队列。
⑥调用exit_files()和exit_fs()，分别递减文件描述符，文件系统数据的引用计数。如果某个引用计数为0，就代表没有进程在使用相应的资源，此时可以释放。
⑦把存放在task_struct的exit_code成员的任务推出代码置为由exit()提供的推出代码，或者去完成其他由内核机制规定的推出动作，退出代码存放在这里供父进程随时检索。
⑧exit_notify()向父进程发信号，给子进程重新找养父，养父为线程组中的其他线程或者为init进程，并把进程状态(task_struct的exit_state中)置为EXIT_ZOBIE.
⑨do_exit()调用schedule()切换到新的进程。处于EXIT_ZOBIE的进程永远不会再被调度，do_exit()永不返回。

至此，进程相关的所有资源都被释放（假设是独享），现在占用的资源就只有内核栈，thread_info结构和task_struct结构，此时进程存在的唯一目的是向它的父进程提供信息。

#### 删除进程描述符
调用do_exit()之后，线程已经僵死，但系统还保留有其进程描述符，这样系统有办法在子进程和终结后仍能获得它的信息。进程终结时所需的清理工作和删除进程描述符分开执行。

wait()函数族都是调用wait4()来实现的，它的标准动作是挂起调用它的进程，直到其中的一个子进程推出，此时函数会返回孩子进程的PID，且调用该函数时提供的指针会包含子函数退出时的代码。

当最终需要释放进程描述符是，会调用release_task()。

①调用__exit_signal()à调用_unhash_process()à调用detach_pid()从pidhash上删除该进程，同时也要从任务队列中删除该进程。
②_exit_signal()释放目前僵尸进程所使用的剩余资源，并进行最终统计和记录。
③如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么release_task()就要通知僵死的领头进程的父进程。
④release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放task_struct所占的slab高速缓存。

至此，进程描述符和所有进程独享的资源就全部释放掉了。

#### 孤儿进程
如果父进程在子进程之前退出，就必须为子进程找到新父亲，以免进程永远处于僵死状态，耗费内存。解决方法是，给子进程在当前进程组找一个线程作为父亲，如果不行，就让init作为其父进程。
do_exit()会调用exit_notify()，该函数会调用forget_original_parent()，而后会调用find_new_reaper()来执行寻父过程。

一旦系统为进程成功找到和设置了新父进程，就不会再出现驻留僵死进程的危险，init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。
