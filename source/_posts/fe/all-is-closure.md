---
title: 一切皆为闭包
date: 2014-03-06 19:03:07
tags:
description: 哈哈哈哈，闭包的问题。
---
我记得我曾经说过，一切皆为闭包！

关于闭包可能很多人第一时间会想起这样一句代码：
``` javascript
var foo = function(){
  var i = 0;
  return function(){
    console.log(++i);
  }
}
var bar = foo();
bar();
```
是的，这确实是一个闭包，这是由于函数的作用域引起的。

内部函数访问变量，需要查询到外部的作用域，所以JS将外部作用域中的i保留下来，且只有bar的作用域能够访问。

那么我今天突然想到曾经碰到的问题，一切皆是闭包，为什么呢？

于是做一猜想如下，如果将这上面的i放到全局作用域中，会是怎么样的情况呢？

以前不是说一切都是闭包么，全局的作用域应该也是的


``` javascript
var i = 0;
for(var t = 0;t < 10 ;t++){
  (function(){
    console.log(++i);
  }());
}
```


输出结果如下：
![](/postimg/20140306185826453.png)


于是根据我理解的作用域概念，这里的for循环是没有块级作用域的，那么可以直接忽略。

在function() 中保留了对全局变量i的引用，所以导致了全局作用域中的i在内存中locked.

从这里，我似乎找到了一丝关于js中一切皆是闭包的证据。

清晨起来，似乎想起一些其它的情况，当它不是自启动函数的函数，而只是一个简单的全局函数变量的时候

是否会符合上述的规律呢？故做如下一测试：

``` javascript
var i = 0;

var test =  function(){
  console.log(++i);
};
test();
test();
test()
```

哈哈，结果果然不出所料如下，变量i依旧被locked在内存中：

![](/postimag/20140307084226125.png)

这与当初猜想结果不谋而合，似乎多一些证据的存在。我也这是为什么我们建议不要使用全局变量的一个原因吧。

虽然大多数都在强调会导致变量污染。但在这里，会导致变量被锁在内存中，从而导致内存增加，甚至严重内存泄露。

个人观点，学有所得，记录之，以防遗忘。