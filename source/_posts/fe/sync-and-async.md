---
title: 异步与同步
date: 2018-10-18
tags:
description: 关于异步与同步的一点想法。
---

#### 有言在先
闲来无事的一些想法

#### 异步产生的原因
>之所以有异步，那么一定是某些情况下，同步有一些问题，才会出现异步。

>那么异步是什么呢？ 
>那么先看同步出现的问题，同步表示一个人（或者执行环境）在做执行一个任务时是不间断的，后面的任务必须等到前面的任务执行完成才有机会被执行。那么这里的等待时间就被白白的浪费了，既然是等待的时间，那为什么不可以用来去做一些别的事情呢？ 比如在排队的时候，完全可以去做一些别的事情，比如看会书，斗会地主都可以。

>那么异步是什么情况呢？ 异步将一个事情分成了两个阶段，一个当前立刻执行，一个在将来执行（具体在何时执行不清楚，所以出现了事件循环机制） ，就比如在银行取钱，只需要先拿一个号，然后就可以去做别的事情，等到服务员叫到你的事情，再回来处理业务就可以了，不用白白的银行里等待。
那么这里产生了一个问题，对于异步似乎出现了多个线程，而不是之前所说的JavaScript是单线程执行。
其实这里所说的JS是单线程只是说的是JS引擎是单线程执行，而浏览器本身是由多个线程进行控制的。
（另外还有一个点，上面所说的同步即使是在多线程的情况下，也是需要进行等待的，否则就不会有死锁等问题出现了）。
比如一个ajax请求，JS引擎负责执行JS代码，但是发送HTTP请求，以及接收HTTP响应，则是网络层所做的事。JS引擎执行完JS后，通知网络layer发送请求，就给事件循环队列中加入一个callback方法，然后继续执行后面的JS代码，等到网络层接收到请求响应之后，并且JS引擎空闲下来的时候（如果不空闲，就会等待）就调用callback方法。

#### 关于文件加载
>对于同步的文件加载过程是，先加载，加载成功之后，自动执行。但是对于异步的文件加载，则是先加载，加载之后并不会自动执行，需要手动调用才会执行。
这里是由于同步加载时，宿主环境知道文件何时加载完成，并且宿主环境一直在阻塞等待文件加载。而对于异步的情况则不同，宿主环境只是给了网络层一个信号，加载此文件，（而并不会等待该文件加载完成)，然后开始执行后面的代码，那么宿主环境是无法预料到文件何时加载完成，只能通过传递一个callback给到事件循环队列中，当文件加载完成之后，并且浏览器有空闲的时候，触发callback，然后手动执行文件。

#### 关于webpack的 require.ensure与import()方法的思考
require.ensure异步加载模块
``` javascript
require.ensure(['b'], function(require) {
  var c = require('c');//此处如果不调用require(c),那么b中的代码也不会执行

  // Do something special...
});
```
import方法加载模块方式
``` javascript
import("./module").then(module => {
    return module.default;
  }).catch(err => {
    console.log("Chunk loading failed");
  });
```
那么为什么import中没有回调方法呢，只是在then中返回了一个模块default.

个人觉得，应该是由于ES模块与CommonJS模块执行的区别才导致了如此的问题。

#### commonJS 与  ESModule的区别
- 书写方式不同
commonJs引入模块使用require，而ES使用 import
- 输出方式不同
commonJS输出其实是作为一个对象输出，所以使用的是 module.exports或者exports，而ES使用export，虽然单词只是多了一个s，但是可以理解为es每一个输出是一个模块，而commonJS本质则是一个对象。
- 加载方式不同
commonJS在requrie加载里就已经执行代码，则ES则是在编译阶段进行引用，也就是加载加入了一个模块的引用而已。
- 其他
在commonJS加载中，如果修改已经被加载过的模块中的数据，已经引用的模块中不会有变化。
而在ES加载中，则修改会被同步过来，因为上面说是ES加载只是加载了一个引用。而commonJS则是加载了一个复制模块。